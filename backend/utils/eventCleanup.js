import EventEmitter from 'events';\nimport memoryManager from '../services/memoryManager.service.js';\n\nclass SafeEventEmitter extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.setMaxListeners(options.maxListeners || 20);\n    this.listenerCount = 0;\n    this.cleanupTasks = new Set();\n    \n    // Track this emitter\n    memoryManager.trackConnection(`emitter-${Date.now()}`, this);\n  }\n\n  on(event, listener) {\n    this.listenerCount++;\n    \n    // Wrap listener to track cleanup\n    const wrappedListener = (...args) => {\n      try {\n        return listener(...args);\n      } catch (error) {\n        console.error(`Event listener error for ${event}:`, error);\n      }\n    };\n    \n    super.on(event, wrappedListener);\n    \n    // Add cleanup task\n    const cleanup = () => this.removeListener(event, wrappedListener);\n    this.cleanupTasks.add(cleanup);\n    \n    return this;\n  }\n\n  once(event, listener) {\n    const wrappedListener = (...args) => {\n      this.listenerCount--;\n      try {\n        return listener(...args);\n      } catch (error) {\n        console.error(`One-time event listener error for ${event}:`, error);\n      }\n    };\n    \n    super.once(event, wrappedListener);\n    return this;\n  }\n\n  removeListener(event, listener) {\n    this.listenerCount--;\n    return super.removeListener(event, listener);\n  }\n\n  removeAllListeners(event) {\n    if (event) {\n      const count = this.listenerCount(event);\n      this.listenerCount -= count;\n    } else {\n      this.listenerCount = 0;\n    }\n    return super.removeAllListeners(event);\n  }\n\n  cleanup() {\n    // Run all cleanup tasks\n    for (const cleanup of this.cleanupTasks) {\n      try {\n        cleanup();\n      } catch (error) {\n        console.error('Cleanup task error:', error);\n      }\n    }\n    \n    this.cleanupTasks.clear();\n    this.removeAllListeners();\n    this.listenerCount = 0;\n  }\n\n  getStats() {\n    return {\n      listenerCount: this.listenerCount,\n      eventNames: this.eventNames(),\n      maxListeners: this.getMaxListeners()\n    };\n  }\n}\n\n// Utility functions for managing event listeners\nexport const createSafeEmitter = (options) => {\n  return new SafeEventEmitter(options);\n};\n\nexport const wrapEventEmitter = (emitter) => {\n  const originalOn = emitter.on;\n  const originalOnce = emitter.once;\n  const listeners = new Set();\n  \n  emitter.on = function(event, listener) {\n    listeners.add({ event, listener });\n    return originalOn.call(this, event, listener);\n  };\n  \n  emitter.once = function(event, listener) {\n    const wrappedListener = (...args) => {\n      listeners.delete({ event, listener: wrappedListener });\n      return listener(...args);\n    };\n    listeners.add({ event, listener: wrappedListener });\n    return originalOnce.call(this, event, wrappedListener);\n  };\n  \n  emitter.cleanup = function() {\n    for (const { event, listener } of listeners) {\n      this.removeListener(event, listener);\n    }\n    listeners.clear();\n  };\n  \n  return emitter;\n};\n\n// Auto-cleanup for request/response cycles\nexport const attachCleanup = (req, res, cleanupFn) => {\n  const cleanup = () => {\n    try {\n      cleanupFn();\n    } catch (error) {\n      console.error('Request cleanup error:', error);\n    }\n  };\n  \n  res.on('finish', cleanup);\n  res.on('close', cleanup);\n  req.on('close', cleanup);\n  req.on('aborted', cleanup);\n};\n\nexport default SafeEventEmitter;